@using ChainSharp.Effect.Orchestration.Mediator.Services.WorkflowBus
@using System.Text.Json.Nodes
@using System.Text.RegularExpressions
@inject IServiceScopeFactory ScopeFactory
@inject DialogService DialogService

<RadzenStack Gap="1rem">
    <RadzenText TextStyle="TextStyle.Subtitle1">
        Input Type: <strong>@Registration.InputTypeName</strong>
    </RadzenText>

    <RadzenTabs @bind-SelectedIndex="_selectedTab">
        <Tabs>
            <RadzenTabsItem Text="Form">
                <RadzenStack Gap="0.75rem" class="rz-mt-2">
                    @foreach (var prop in _inputProperties)
                    {
                        var underlying = Nullable.GetUnderlyingType(prop.PropertyType) ?? prop.PropertyType;

                        @if (underlying == typeof(bool))
                        {
                            <RadzenFormField Text="@FormatLabel(prop.Name)" Variant="Variant.Outlined" class="rz-w-100">
                                <RadzenSwitch Value="@(GetFormValue<bool>(prop.Name))"
                                              ValueChanged="@((bool v) => SetFormValue(prop.Name, v))"
                                              Disabled="@_running" />
                            </RadzenFormField>
                        }
                        else if (underlying.IsEnum)
                        {
                            <RadzenFormField Text="@FormatLabel(prop.Name)" Variant="Variant.Outlined" class="rz-w-100">
                                <RadzenDropDown TValue="string"
                                                Data="@Enum.GetNames(underlying)"
                                                Value="@(GetFormValue<string>(prop.Name))"
                                                ValueChanged="@((string v) => SetFormValue(prop.Name, v))"
                                                Disabled="@_running" />
                            </RadzenFormField>
                        }
                        else
                        {
                            <RadzenFormField Text="@FormatLabel(prop.Name)" Variant="Variant.Outlined" class="rz-w-100">
                                <RadzenTextBox Value="@(GetFormValue<string>(prop.Name))"
                                               Change="@(v => SetFormValue(prop.Name, v))"
                                               Placeholder="@GetPlaceholder(underlying)"
                                               ReadOnly="@_running" />
                            </RadzenFormField>
                        }
                    }
                </RadzenStack>
            </RadzenTabsItem>
            <RadzenTabsItem Text="JSON">
                <RadzenTextArea @bind-Value="_jsonInput"
                                Placeholder="@($"Enter JSON for {Registration.InputTypeName}")"
                                Rows="10"
                                class="rz-w-100 rz-mt-2"
                                ReadOnly="@_running" />
            </RadzenTabsItem>
        </Tabs>
    </RadzenTabs>

    @if (_result is not null)
    {
        <RadzenCard>
            <RadzenText TextStyle="TextStyle.Subtitle2" class="rz-mb-2">Output</RadzenText>
            <pre style="white-space: pre-wrap; word-break: break-word; max-height: 300px; overflow-y: auto;">@_result</pre>
        </RadzenCard>
    }

    @if (_error is not null)
    {
        <RadzenAlert AlertStyle="AlertStyle.Danger" ShowIcon="true" Variant="Variant.Flat">
            @_error
        </RadzenAlert>
    }

    <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.End" Gap="0.5rem">
        <RadzenButton Text="Cancel"
                      ButtonStyle="ButtonStyle.Light"
                      Click="@(() => DialogService.Close())"
                      Disabled="@_running" />
        <RadzenButton Text="Run"
                      Icon="play_arrow"
                      ButtonStyle="ButtonStyle.Primary"
                      Click="@RunWorkflow"
                      IsBusy="@_running"
                      Disabled="@_running" />
    </RadzenStack>
</RadzenStack>

@code {
    [Parameter] public required WorkflowRegistration Registration { get; set; }

    private static readonly MethodInfo RunAsyncMethod =
        typeof(IWorkflowBus).GetMethod(nameof(IWorkflowBus.RunAsync), 1, [typeof(object), typeof(Metadata)])!;

    private int _selectedTab;
    private string _jsonInput = "";
    private string? _result;
    private string? _error;
    private bool _running;

    private PropertyInfo[] _inputProperties = [];
    private readonly Dictionary<string, object?> _formValues = new();

    protected override void OnInitialized()
    {
        _inputProperties = Registration.InputType
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(p => p.CanRead)
            .ToArray();

        foreach (var prop in _inputProperties)
        {
            var underlying = Nullable.GetUnderlyingType(prop.PropertyType) ?? prop.PropertyType;

            if (underlying == typeof(bool))
                _formValues[prop.Name] = false;
            else if (underlying.IsEnum)
                _formValues[prop.Name] = Enum.GetNames(underlying).FirstOrDefault() ?? "";
            else
                _formValues[prop.Name] = "";
        }
    }

    private T GetFormValue<T>(string name) =>
        _formValues.TryGetValue(name, out var value) && value is T typed ? typed : default!;

    private void SetFormValue(string name, object? value) =>
        _formValues[name] = value;

    private async Task RunWorkflow()
    {
        _error = null;
        _result = null;
        _running = true;

        try
        {
            var input = _selectedTab == 0
                ? BuildInputFromForm()
                : JsonSerializer.Deserialize(_jsonInput, Registration.InputType);

            if (input is null)
            {
                _error = $"Deserialization returned null. Ensure the input matches {Registration.InputTypeName}.";
                return;
            }

            await using var scope = ScopeFactory.CreateAsyncScope();
            var workflowBus = scope.ServiceProvider.GetRequiredService<IWorkflowBus>();

            var genericMethod = RunAsyncMethod.MakeGenericMethod(Registration.OutputType);
            var task = (Task)genericMethod.Invoke(workflowBus, [input, null])!;
            await task;

            var output = task.GetType().GetProperty("Result")!.GetValue(task);
            _result = JsonSerializer.Serialize(output, new JsonSerializerOptions { WriteIndented = true });
        }
        catch (TargetInvocationException tie) when (tie.InnerException is not null)
        {
            _error = tie.InnerException.Message;
        }
        catch (JsonException je)
        {
            _error = $"Invalid JSON: {je.Message}";
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _running = false;
        }
    }

    private object? BuildInputFromForm()
    {
        var jsonObj = new JsonObject();

        foreach (var prop in _inputProperties)
        {
            var value = _formValues.GetValueOrDefault(prop.Name);
            jsonObj[prop.Name] = ToJsonNode(value, prop.PropertyType);
        }

        return JsonSerializer.Deserialize(
            jsonObj.ToJsonString(),
            Registration.InputType,
            new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
        );
    }

    private static JsonNode? ToJsonNode(object? value, Type targetType)
    {
        var underlying = Nullable.GetUnderlyingType(targetType) ?? targetType;

        if (value is bool b)
            return JsonValue.Create(b);

        if (value is not string s || string.IsNullOrEmpty(s))
            return Nullable.GetUnderlyingType(targetType) is not null ? null : ToDefault(underlying);

        if (underlying == typeof(string))
            return JsonValue.Create(s);
        if (underlying.IsEnum)
            return JsonValue.Create(s);
        if (underlying == typeof(int) && int.TryParse(s, out var i))
            return JsonValue.Create(i);
        if (underlying == typeof(long) && long.TryParse(s, out var l))
            return JsonValue.Create(l);
        if (underlying == typeof(double) && double.TryParse(s, out var d))
            return JsonValue.Create(d);
        if (underlying == typeof(decimal) && decimal.TryParse(s, out var dec))
            return JsonValue.Create(dec);
        if (underlying == typeof(float) && float.TryParse(s, out var f))
            return JsonValue.Create(f);
        if (underlying == typeof(short) && short.TryParse(s, out var sh))
            return JsonValue.Create(sh);
        if (underlying == typeof(byte) && byte.TryParse(s, out var by))
            return JsonValue.Create(by);
        if (underlying == typeof(Guid) && Guid.TryParse(s, out var g))
            return JsonValue.Create(g);
        if (underlying == typeof(DateTime) && DateTime.TryParse(s, out var dt))
            return JsonValue.Create(dt);
        if (underlying == typeof(DateTimeOffset) && DateTimeOffset.TryParse(s, out var dto))
            return JsonValue.Create(dto);
        if (underlying == typeof(bool) && bool.TryParse(s, out var bo))
            return JsonValue.Create(bo);

        // Complex types: try parsing as JSON, fall back to string
        try { return JsonNode.Parse(s); }
        catch { return JsonValue.Create(s); }
    }

    private static JsonNode? ToDefault(Type type)
    {
        if (type == typeof(string)) return JsonValue.Create("");
        if (type == typeof(bool)) return JsonValue.Create(false);
        if (type.IsValueType) return JsonValue.Create(0);
        return null;
    }

    private static string FormatLabel(string name) =>
        Regex.Replace(name, @"(?<=[a-z0-9])(?=[A-Z])", " ");

    private static string GetPlaceholder(Type type) => type switch
    {
        _ when type == typeof(string) => "Enter text",
        _ when type == typeof(int) || type == typeof(long) || type == typeof(short) => "Enter number",
        _ when type == typeof(double) || type == typeof(float) || type == typeof(decimal) => "Enter decimal",
        _ when type == typeof(Guid) => "Enter GUID",
        _ when type == typeof(DateTime) || type == typeof(DateTimeOffset) => "yyyy-MM-dd HH:mm:ss",
        _ => $"Enter {type.Name}",
    };
}
